# 아이디가 필요해

PK 는 좋은 데이터베이스 설계에 정말 중요하다. PK 는 테이블 내의 모든 행이 유일함을 보장하기 때문에, 각 행에 접근하는 논리적 메커니즘이 되고 중복 행이 저장되는 것을 방지한다.

보통은 비지니스 규칙과 연관된 컬럼들을 PK 로 묶는 경우도 있는데, 비지니스 규칙은 언제든 변할 수 있으므로, 인조키를 만들어서 사용하는 편이 좋다.

## 경쟁 상태(race condition)

어떤 사람은 최댓값에 1을 더해 새 행을 위한 키값으로 사용한다.

```
SELECT MAX(id) + 1 AS next_bug_id FROM Bugs;
```

이러한 방식은 두 개의 클라이언트가 동시에 쿼리를 실행할 수 있다면 안전하지 않다. 두 클라이언트에서 같은 값을 사용하게 될 수도 있기 때문이다.
이런 것을 `경쟁 상태(race condition)`이라고 한다. 

경쟁 상태를 피하기 위해서는 동시에 삽입하는 것을 막아야 하고 최댓값을 구한 다음 이를 이용해 행을 삽입해야 한다. 이렇게 하기 위해서는 `전체 테이블 잠금(lock)`을 사용해야 한다.
`행 수준의 잠금(row-level locking)`으로는 충분하지 않다. 테이블 잠금은 클라이언트의 동시 접근을 막고 DB 요청을 한 줄로 세워 차례로 접근하게 하므로 `병목의 원인`이 된다.

`시퀀스(Sequence)`는 트랜잭션 범위 밖에서 동작해 이 문제를 해결한다. 시퀀스는 여러 클라이언트에 절대 같은 값을 할당하지 않고, 삽입할 행에 사용한 값을 커밋했는지 여부와 상관없이
한 번 할당한 값을 되돌리지도 못한다. 시퀀스는 이런 식으로 동작하기 때문에, 여러 클라이언트가 동시에 유일한 값을 할당받을 수 있고 중복된 값을 할당 받지 않는다고 확신할 수 있다.

다른 클라이언트가 동시에 자신이 사용할 값을 생성하더라도, 시퀀스가 생성한 마지막 값을 확인할 수 있는 함수는 현재 세션에서 생성한 마지막 값을 리턴하므로 경쟁 상태가 없다.

## 안티패턴 인식 방법

테이블에서 PK 칼럼 이름으로 id(지나치게 일반적인 이름)가 사용되고 있으면 이 안티패턴의 징후로 볼 수 있다. 좀 더 의미 있는 이름 대신 id 를 선호해야 할 이유는 없다.

## 안티패턴 사용이 합당한 경우

일부 `ORM Framework` 에서는 CoC(Convention over Configuration)를 통해 개발을 단순화 한다. 이런 프레임워크에서는 모든 테이블이 동일한 방식(컬럼 이름은 id 고 데이터는 Long 인 가상키)으로 PK
를 정의한다고 가정한다.

> 관례는 도움이 될 때만 좋은 것이다.

### 있는 그대로 말하기

PK 에 의미 있는 이름을 선택해야 한다. 예를 들어, Bugs 테이블의 PK 는 bug_id 가 되어야 한다. FK 에서도 가능하다면 같은 이름을 사용해야 한다.
