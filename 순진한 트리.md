# 순진한 트리

## 목표 : 계층구조 저장 및 조회하기

데이터가 재귀적 관계를 가지는 것은 흔한 일이다. 데이터는 트리나 계층적 구조가 될 수 있다. 트리 데이터 구조를 가지는 예에는 다음과 같은 것이 포함된다.

- `조직도`
  - 직원과 관리자의 관계
- `글타래`
  - 답글에 대한 답글

## 안티패턴

### 항상 부모에 의존하기

가장 초보적인 방법은 parent_id 컬럼을 추가해서 같은 테이블 안의 다른 글을 참조 시키는 것이다.

```sql
CREATE TABLE Comments (
  comment_id SERIAL PRIMARY KEY,
  parent_id BIGINT UNSIGNED,
  bug_id BIGNINT UNSIGNED NOT NULL,
  author BIGINT UNSSIGNED NOT NULL,
  comment_date DATETIME NOT NULL,
  comment TEXT NOT NULL,
  FOREIGN KEY (parent_id) REFERENCES Comments(comment_id),
  FOREIGN KEY (bug_id) REFERENCES Bugs(bug_id),
  FOREIGN KEY (author) REFERENCES Accounts(account_id)
);
```

이러한 설계를 `인접 목록(Adjacency List)` 이라 불린다.

#### 인접 목록에서 트리 조회하기

인접 목록은 많은 개발자들이 기본으로 선택하는 방법이지만, 트리에서 필요한 가장 흔한 작업 중 하나인 모든 자식 조회하기를 제대로 하지 못 한다면 안티패턴이 될 수 있다.

- 답글과 그 답글의 바로 아래 자식 얻기

```sql
SELECT c1.*, c2.*
FROM Comments c1 LEFT OUTER JOIN Comments c2
ON c2.parent_id = c1.comment_id
```

#### 트리에서 4단계까지만 가져오는 쿼리

그 이상의 깊이에 있는 데이터는 가져오지 못한다.

```sql
SELECT c1.*, c2.*, c3.*, c4.*
FROM Comments c1
LEFT OUTER JOIN Comments c2
ON c1.comment_id = c2.parent_id
LEFT OUTER JOIN Comments c3
ON c1.comment_id = c3.parent_id
LEFT OUTER JOIN Comments c4
ON c1.comment_id = c4.parent_id
```

이러한 방식은 count() 같은 집계 수치를 계산하기에 어렵다.

데이터베이스에서 대량으로 데이터를 가져오는 방법은 엄청나게 비효율적이다. 전체 트리가 필요한게 아니라, 서브 트리만 필요할 수도 있기 때문이다.

