# 키가 없는 엔트리

## 목표 : 데이터베이스 아키텍처 단순화

RDB 에서 `참조 정합성(Referential Integrity)`은 데이터베이스를 적절히 설계하고 운영하는 데 있어 중요한 부분이다. 어떤 컬럼 또는 컬럼 묶음에 FK 제약조건을 선언하면, 그 컬럼에 들어가는 값은
부모 테이블의 PK 또는 유일키(unique key)에 존재해야 한다.

그러나 어떤 소프트웨어 개발자는 참조 정합성 제약조건을 사용하지 말라고 권고한다. 그 이유에는 다음과 같은 것들이 포함되어 있다.

- 데이터 업데이트 시 제약조건과 충돌할 수 있다.
- 참조 정합성 제약조건을 지원할 수 없는 매우 융통성 있는 데이터베이스 설계를 사용하고 있다.
- FK 에 데이터베이스가 자동 생성하는 인덱스 때문에 성능에 영향을 받는다고 믿는다.
- Fk 를 지원하지 않는 데이터베이스를 사용하고 있다.
- FK 선언을 위해 문법을 찾아봐야 한다.

## 안티패턴 : 제약조건 무시

FK 제약조건을 생략하는 것이 처음에는 데이터베이스 설계를 단순하고 유연하고 빠르게 하는 것처럼 보이겠지만, 다른 방식으로 대가를 치러야 한다. 참조 정합성을 보장하기 위한
코드를 직접 작성해야 하는 책임을 떠안아야 한다.

## 안티패턴 사용이 합당한 경우

FK 제약조건을 지원하지 않는 데이터베이스(Ex. MySQL 의 MyISAM 스토리지 엔진 또는 3.6.19 이전의 SQLite)를 사용할 수 밖에 없는 경우도 있다. 이런 경우라면 `품질 제어 스크립트`같은 것으로
보완하는 수밖에 없다.

## 해법 : 제약조건 선언하기

`오류 검증(mistake proofing)`이란 오류를 방지하거나 바로잡거나 또는 발생 하는 즉시 관심을 가져 제품의 결함을 제거하는 데 도움이 되는 생산 공정을 뜻한다.
이런 실행방안은 품질을 향상시키고 정정 요구를 감소시켜, 추가비용을 상쇄하고도 남는다.

데이터베이스 설계에서도 참조 정합성을 강제하기 위해 FK 를 사용하는 방법으로 `오류 검증`원리를 적용할 수 있다. 데이터 정합성 오류를 찾아내 정정하는 대신, 
처음부터 잘못된 데이터가 입력되지 않도록 할 수 있는 것이다.

### 여러 테이블 변경 지원

FK 는 애플리케이션 코드로 흉내 낼 수 없는 다른 기능이 있다. 바로 `단계적 업데이트(cascading update)`이다.

이 방법을 사용하면 부모 행을 업데이트 또는 삭제할 경우 데이터베이스가 해당 부모를 참조하는 자식 행을 알아서 처리해준다. FK 제약조건의 `ON UPDATE` 나 `ON DELETE` 절을 선언하는 방식에 따라
단계적 작업의 결과를 제어할 수 있다.

### 오버헤드? 그닥~

FK 제약조건이 약간의 오버헤드가 있는 것은 사실이다. 그러나 다른 대안과 비교했을 때, FK 가 훨씬 효율적이라고 입증되었다.

- INSERT, UPDATE, DELETE 를 날리기 전에 데이터 확인을 위해 SELECT 쿼리를 실행할 필요가 없다.
- 여러 테이블을 변경하기 위해 테이블 잠금을 사용할 필요가 없다.
- 불가피하게 생기는 고아 데이터를 정정하기 위해 품질 제어 스크립트를 주기적으로 돌릴 필요가 없다.
